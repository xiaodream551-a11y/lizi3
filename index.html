<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <title>Cyberpunk Particle Hands</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #04070a;
        --hud: #00f6ff;
        --grid: rgba(0, 255, 255, 0.08);
        --scan: rgba(0, 255, 255, 0.05);
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: "Orbitron", monospace;
        color: var(--hud);
        touch-action: none;
      }

      canvas {
        display: block;
      }

      #bg-grid,
      #scanlines,
      #vignette {
        position: fixed;
        inset: 0;
        pointer-events: none;
      }

      #bg-grid {
        background-image: linear-gradient(var(--grid) 1px, transparent 1px),
          linear-gradient(90deg, var(--grid) 1px, transparent 1px);
        background-size: 52px 52px, 52px 52px;
        opacity: 0.35;
        animation: gridShift 20s linear infinite;
      }

      #scanlines {
        background: repeating-linear-gradient(
          to bottom,
          var(--scan),
          var(--scan) 1px,
          transparent 1px,
          transparent 3px
        );
        mix-blend-mode: screen;
        animation: scanMove 6s linear infinite;
      }

      #vignette {
        background: radial-gradient(
          circle at center,
          rgba(0, 0, 0, 0) 45%,
          rgba(0, 0, 0, 0.55) 70%,
          rgba(0, 0, 0, 0.9) 100%
        );
      }

      #hud {
        position: fixed;
        inset: 0;
        pointer-events: none;
        font-size: 12px;
        letter-spacing: 0.14em;
        text-shadow: 0 0 8px rgba(0, 255, 255, 0.7);
      }

      .hud-block {
        position: absolute;
        white-space: pre;
      }

      .tl {
        top: 18px;
        left: 20px;
      }

      .tr {
        top: 18px;
        right: 20px;
        text-align: right;
      }

      .bl {
        bottom: 18px;
        left: 20px;
      }

      .br {
        bottom: 18px;
        right: 20px;
        text-align: right;
      }

      #status {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 11px;
        letter-spacing: 0.2em;
        color: rgba(0, 255, 255, 0.6);
        pointer-events: none;
      }

      video {
        display: none;
      }

      @keyframes gridShift {
        from {
          background-position: 0 0, 0 0;
        }
        to {
          background-position: 200px 160px, 200px 160px;
        }
      }

      @keyframes scanMove {
        from {
          background-position: 0 -200px;
        }
        to {
          background-position: 0 200px;
        }
      }
    </style>
  </head>
  <body>
    <div id="bg-grid"></div>
    <div id="scanlines"></div>
    <div id="vignette"></div>
    <div id="hud">
      <div class="hud-block tl" id="hud-tl"></div>
      <div class="hud-block tr" id="hud-tr"></div>
      <div class="hud-block bl" id="hud-bl"></div>
      <div class="hud-block br" id="hud-br"></div>
    </div>
    <div id="status">CAMERA INIT</div>
    <video id="video" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.min.js"></script>
    <script>
      (() => {
        const PARTICLE_COUNT = 12000;
        const TEXT_SIZE = 150;
        const TEXT_SAMPLE_STEP = 6;
        const TEXT_JITTER = 1.5;
        const BASE_SIZE = 3.4;
        const MIRROR_INPUT = true;
        const SPRING = 0.16;
        const DAMPING = 0.84;
        const COLOR_EASE = 0.12;
        const REPEL_RADIUS = 70;
        const REPEL_STRENGTH = 5.0;
        const RIPPLE_RADIUS = 140;
        const RIPPLE_STRENGTH = 1.2;
        const JUMP_SPEED = 0.012;
        const JUMP_FORCE = 0.045;
        const JUMP_MAX = 18;
        const JUMP_SIDE = 0.35;

        const COLORS = {
          hello: 0x00ffff,
          gemini: 0xffff00,
          cool: 0xff00ff,
          bye: 0x00ff88,
          cloud: 0x88f6ff,
          catch: 0xff8a00,
          catchDark: 0x2a0e00,
        };

        const hudTL = document.getElementById("hud-tl");
        const hudTR = document.getElementById("hud-tr");
        const hudBL = document.getElementById("hud-bl");
        const hudBR = document.getElementById("hud-br");
        const statusEl = document.getElementById("status");

        let width = window.innerWidth;
        let height = window.innerHeight;
        let sphereRadius = Math.min(width, height) * 0.18;

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(
          -width / 2,
          width / 2,
          height / 2,
          -height / 2,
          -1000,
          1000
        );
        camera.position.z = 10;

        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
          powerPreference: "high-performance",
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(width, height);
        renderer.setClearColor(0x000000, 0);
        document.body.appendChild(renderer.domElement);

        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const velocities = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const targetColors = new Float32Array(PARTICLE_COUNT * 3);
        const baseSphere = new Float32Array(PARTICLE_COUNT * 3);
        const cloudTargets = new Float32Array(PARTICLE_COUNT * 3);
        const jumpSeeds = new Float32Array(PARTICLE_COUNT);
        const sizes = new Float32Array(PARTICLE_COUNT);
        const sizeSeeds = new Float32Array(PARTICLE_COUNT);

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1));

        const material = new THREE.RawShaderMaterial({
          uniforms: {
            uPixelRatio: { value: renderer.getPixelRatio() },
          },
          vertexShader: `
            precision highp float;
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            uniform float uPixelRatio;
            attribute vec3 position;
            attribute vec3 color;
            attribute float size;
            varying vec3 vColor;
            void main() {
              vColor = color;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              gl_PointSize = size * uPixelRatio;
            }
          `,
          fragmentShader: `
            precision mediump float;
            varying vec3 vColor;
            void main() {
              vec2 uv = gl_PointCoord - vec2(0.5);
              float d = length(uv);
              float core = 1.0 - smoothstep(0.0, 0.5, d);
              float halo = 1.0 - smoothstep(0.0, 0.85, d);
              float alpha = clamp(core + halo * 0.35, 0.0, 1.0);
              gl_FragColor = vec4(vColor, alpha);
            }
          `,
          blending: THREE.AdditiveBlending,
          transparent: true,
          depthTest: false,
          depthWrite: false,
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        const tempColor = new THREE.Color();
        const scatterColor = new THREE.Color(COLORS.cloud);

        function seedParticles() {
          for (let i = 0; i < PARTICLE_COUNT; i++) {
            const idx = i * 3;
            const x = (Math.random() - 0.5) * width;
            const y = (Math.random() - 0.5) * height;
            positions[idx] = x;
            positions[idx + 1] = y;
            positions[idx + 2] = 0;
            targetPositions[idx] = x;
            targetPositions[idx + 1] = y;
            targetPositions[idx + 2] = 0;
            velocities[idx] = 0;
            velocities[idx + 1] = 0;
            velocities[idx + 2] = 0;
            jumpSeeds[i] = Math.random() * Math.PI * 2;
            sizes[i] = BASE_SIZE;
            sizeSeeds[i] = Math.random();
            tempColor.setHex(COLORS.hello);
            colors[idx] = tempColor.r;
            colors[idx + 1] = tempColor.g;
            colors[idx + 2] = tempColor.b;
            targetColors[idx] = colors[idx];
            targetColors[idx + 1] = colors[idx + 1];
            targetColors[idx + 2] = colors[idx + 2];
          }
        }

        function generateSpherePoints(radius) {
          const offset = 2 / PARTICLE_COUNT;
          const increment = Math.PI * (3 - Math.sqrt(5));
          for (let i = 0; i < PARTICLE_COUNT; i++) {
            const y = i * offset - 1 + offset / 2;
            const r = Math.sqrt(1 - y * y);
            const phi = i * increment;
            const x = Math.cos(phi) * r;
            const z = Math.sin(phi) * r;
            const idx = i * 3;
            baseSphere[idx] = x * radius;
            baseSphere[idx + 1] = y * radius;
            baseSphere[idx + 2] = z * radius;
          }
        }

        function generateCloudTargets() {
          for (let i = 0; i < PARTICLE_COUNT; i++) {
            const idx = i * 3;
            cloudTargets[idx] = (Math.random() - 0.5) * width * 0.9;
            cloudTargets[idx + 1] = (Math.random() - 0.5) * height * 0.9;
            cloudTargets[idx + 2] = 0;
          }
        }

        function sampleTextPoints(text) {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          canvas.width = 1300;
          canvas.height = 320;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#fff";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `700 ${TEXT_SIZE}px Orbitron, sans-serif`;
          ctx.fillText(text, canvas.width / 2, canvas.height / 2);
          const image = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
          const points = [];
          const step = TEXT_SAMPLE_STEP;
          for (let y = 0; y < canvas.height; y += step) {
            for (let x = 0; x < canvas.width; x += step) {
              const idx = (y * canvas.width + x) * 4;
              if (image[idx + 3] > 90) {
                points.push(x, y);
              }
            }
          }
          return {
            points,
            width: canvas.width,
            height: canvas.height,
          };
        }

        function applyTextTargets(text, colorHex) {
          const { points, width: tw, height: th } = sampleTextPoints(text);
          const scale = Math.min((width * 0.95) / tw, (height * 0.42) / th);
          const total = points.length / 2 || 1;
          tempColor.setHex(colorHex);
          for (let i = 0; i < PARTICLE_COUNT; i++) {
            const idx = i * 3;
            const pIndex = (i % total) * 2;
            const px = points[pIndex];
            const py = points[pIndex + 1];
            const x = (px - tw / 2) * scale + (Math.random() - 0.5) * TEXT_JITTER;
            const y = (th / 2 - py) * scale + (Math.random() - 0.5) * TEXT_JITTER;
            targetPositions[idx] = x;
            targetPositions[idx + 1] = y;
            targetPositions[idx + 2] = 0;
            targetColors[idx] = tempColor.r;
            targetColors[idx + 1] = tempColor.g;
            targetColors[idx + 2] = tempColor.b;
          }
        }

        function applyCloudTargets() {
          tempColor.setHex(COLORS.cloud);
          for (let i = 0; i < PARTICLE_COUNT; i++) {
            const idx = i * 3;
            targetPositions[idx] = cloudTargets[idx];
            targetPositions[idx + 1] = cloudTargets[idx + 1];
            targetPositions[idx + 2] = 0;
            targetColors[idx] = tempColor.r;
            targetColors[idx + 1] = tempColor.g;
            targetColors[idx + 2] = tempColor.b;
          }
        }

        let leftCount = 0;
        let leftPresent = false;
        let rightPresent = false;
        let rightOpen = false;
        let leftOpen = false;
        let rightIndex = { x: 0, y: 0, valid: false };
        let leftPalm = { x: 0, y: 0, valid: false };

        let mode = "text";
        let activeTextKey = 1;
        let activeTextLabel = "你好";
        let modePulse = 0;

        function triggerPulse(intensity = 1.3) {
          modePulse = Math.max(modePulse, intensity);
        }

        function setModeText(key) {
          mode = "text";
          activeTextKey = key;
          triggerPulse();
          if (key === 1) {
            activeTextLabel = "你好";
            applyTextTargets("你好", COLORS.hello);
          } else if (key === 2) {
            activeTextLabel = "我是肖峻铭";
            applyTextTargets("我是肖峻铭", COLORS.gemini);
          } else if (key === 3) {
            activeTextLabel = "很高兴见到你";
            applyTextTargets("很高兴见到你", COLORS.cool);
          } else if (key === 4) {
            activeTextLabel = "再见";
            applyTextTargets("再见", COLORS.bye);
          }
        }

        function setModeCloud() {
          mode = "cloud";
          activeTextLabel = "STAR CLOUD";
          triggerPulse();
          generateCloudTargets();
          applyCloudTargets();
        }

        function setModeCatch() {
          mode = "catch";
          activeTextLabel = "CATCH MODE";
          triggerPulse();
        }

        function updateCatchTargets(time) {
          if (!leftPalm.valid) {
            return;
          }
          const cx = leftPalm.x;
          const cy = leftPalm.y;
          const angle = time * 0.0006;
          const tilt = time * 0.0004;
          const cosA = Math.cos(angle);
          const sinA = Math.sin(angle);
          const cosB = Math.cos(tilt);
          const sinB = Math.sin(tilt);

          const baseColor = new THREE.Color(COLORS.catch);
          const lineColor = new THREE.Color(COLORS.catchDark);

          for (let i = 0; i < PARTICLE_COUNT; i++) {
            const idx = i * 3;
            const bx = baseSphere[idx];
            const by = baseSphere[idx + 1];
            const bz = baseSphere[idx + 2];

            let x = bx * cosA + bz * sinA;
            let z = -bx * sinA + bz * cosA;
            let y = by * cosB - z * sinB;
            z = by * sinB + z * cosB;

            const len = Math.sqrt(x * x + y * y + z * z) || 1;
            const nx = x / len;
            const ny = y / len;
            const nz = z / len;
            const bounce = Math.abs(Math.sin(time * 0.006 + i * 0.02)) * 6;

            targetPositions[idx] = cx + x + nx * bounce;
            targetPositions[idx + 1] = cy + y + ny * bounce;
            targetPositions[idx + 2] = z + nz * bounce;

            const theta = Math.atan2(z, x);
            const phi = Math.acos(y / (sphereRadius + 0.001));
            const seam =
              Math.abs(Math.sin(theta * 2.4)) < 0.16 ||
              Math.abs(Math.sin(phi * 3.4)) < 0.12;

            const color = seam ? lineColor : baseColor;
            targetColors[idx] = color.r;
            targetColors[idx + 1] = color.g;
            targetColors[idx + 2] = color.b;
          }
        }

        function updateHud(fps) {
          hudTL.textContent = `FPS ${fps.toFixed(1)}\nPART ${PARTICLE_COUNT}`;
          hudTR.textContent = `LEFT ${leftPresent ? leftCount : "---"}\nMODE ${
            leftOpen ? "OPEN" : "IDLE"
          }`;
          hudBL.textContent = `RIGHT ${rightPresent ? (rightOpen ? "OPEN" : "A") : "---"}\nINDEX ${
            rightIndex.valid ? "TRACK" : "LOST"
          }`;
          hudBR.textContent = `STATE ${mode.toUpperCase()}\nTARGET ${activeTextLabel}`;
        }

        function toWorld(landmark) {
          const lx = MIRROR_INPUT ? 1 - landmark.x : landmark.x;
          return {
            x: (lx - 0.5) * width,
            y: (0.5 - landmark.y) * height,
          };
        }

        function countExtended(landmarks, handedness) {
          const tips = [4, 8, 12, 16, 20];
          const pips = [3, 6, 10, 14, 18];
          let count = 0;
          const thumbTip = landmarks[tips[0]];
          const thumbIp = landmarks[pips[0]];
          if (handedness === "Right") {
            if (thumbTip.x < thumbIp.x) count += 1;
          } else {
            if (thumbTip.x > thumbIp.x) count += 1;
          }
          for (let i = 1; i < tips.length; i++) {
            if (landmarks[tips[i]].y < landmarks[pips[i]].y) {
              count += 1;
            }
          }
          return count;
        }

        function handleHands(results) {
          leftPresent = false;
          rightPresent = false;
          rightIndex.valid = false;
          leftPalm.valid = false;
          leftCount = 0;
          rightOpen = false;
          leftOpen = false;

          if (results.multiHandLandmarks && results.multiHandedness) {
            results.multiHandLandmarks.forEach((landmarks, i) => {
              const rawLabel = results.multiHandedness[i].label;
              const label =
                MIRROR_INPUT && rawLabel
                  ? rawLabel === "Left"
                    ? "Right"
                    : "Left"
                  : rawLabel;
              const count = countExtended(landmarks, rawLabel);
              if (label === "Left") {
                leftPresent = true;
                leftCount = count;
                leftOpen = count >= 5;
                const palm = [0, 5, 9, 13, 17]
                  .map((idx) => landmarks[idx])
                  .reduce(
                    (acc, item) => {
                      acc.x += item.x;
                      acc.y += item.y;
                      return acc;
                    },
                    { x: 0, y: 0 }
                  );
                palm.x /= 5;
                palm.y /= 5;
                const worldPalm = toWorld(palm);
                leftPalm.x = worldPalm.x;
                leftPalm.y = worldPalm.y;
                leftPalm.valid = true;
              } else if (label === "Right") {
                rightPresent = true;
                rightOpen = count >= 5;
                const indexTip = landmarks[8];
                const worldTip = toWorld(indexTip);
                rightIndex.x = worldTip.x;
                rightIndex.y = worldTip.y;
                rightIndex.valid = true;
              }
            });
          }

          const prevKey = activeTextKey;
          const leftGestureActive =
            leftPresent && leftCount >= 1 && leftCount <= 4;
          if (!leftOpen && leftGestureActive) {
            activeTextKey = leftCount;
          }

          const catchMode = leftOpen;
          const cloudMode = rightOpen && !catchMode && !leftGestureActive;

          if (catchMode && mode !== "catch") {
            setModeCatch();
          } else if (cloudMode && mode !== "cloud") {
            setModeCloud();
          } else if (!catchMode && !cloudMode && mode !== "text") {
            setModeText(activeTextKey);
          } else if (
            !catchMode &&
            !cloudMode &&
            mode === "text" &&
            activeTextKey !== prevKey
          ) {
            setModeText(activeTextKey);
          }
        }

        function updateParticles(time) {
          modePulse = Math.max(0, modePulse - 0.02);
          if (mode === "catch") {
            updateCatchTargets(time);
          }

          const repelActive = rightIndex.valid && !rightOpen;
          const rippleActive = rightIndex.valid && rightOpen && mode !== "catch";
          const jumpActive = mode === "catch" && leftPalm.valid;
          const scatterSizeActive = repelActive || rightOpen || mode === "cloud";
          const rx = rightIndex.x;
          const ry = rightIndex.y;
          const cx = leftPalm.x;
          const cy = leftPalm.y;

          for (let i = 0; i < PARTICLE_COUNT; i++) {
            const idx = i * 3;
            let dx = targetPositions[idx] - positions[idx];
            let dy = targetPositions[idx + 1] - positions[idx + 1];
            let dz = targetPositions[idx + 2] - positions[idx + 2];

            const springBoost = SPRING + modePulse * 0.12;
            velocities[idx] += dx * springBoost;
            velocities[idx + 1] += dy * springBoost;
            velocities[idx + 2] += dz * springBoost;

            if (repelActive) {
              const ox = positions[idx] - rx;
              const oy = positions[idx + 1] - ry;
              const dist = Math.sqrt(ox * ox + oy * oy);
              if (dist < REPEL_RADIUS && dist > 0.001) {
                const boost = 1 + modePulse * 0.5;
                const force =
                  (1 - dist / REPEL_RADIUS) * REPEL_STRENGTH * boost;
                velocities[idx] += (ox / dist) * force;
                velocities[idx + 1] += (oy / dist) * force;
              }
            } else if (rippleActive) {
              const ox = positions[idx] - rx;
              const oy = positions[idx + 1] - ry;
              const dist = Math.sqrt(ox * ox + oy * oy);
              if (dist < RIPPLE_RADIUS && dist > 0.001) {
                const wave =
                  Math.sin(dist * 0.08 - time * 0.006) * RIPPLE_STRENGTH;
                velocities[idx] += (ox / dist) * wave;
                velocities[idx + 1] += (oy / dist) * wave;
              }
            }

            if (jumpActive) {
              const ox = positions[idx] - cx;
              const oy = positions[idx + 1] - cy;
              const dist = Math.sqrt(ox * ox + oy * oy) || 1;
              const amp = Math.min(JUMP_MAX, dist * 0.06);
              const seed = jumpSeeds[i];
              const jump = Math.sin(time * JUMP_SPEED + seed) * amp;
              velocities[idx + 1] += jump * JUMP_FORCE;
              velocities[idx] +=
                Math.cos(time * (JUMP_SPEED * 0.9) + seed) *
                amp *
                JUMP_FORCE *
                JUMP_SIDE;
            }

            velocities[idx] *= DAMPING;
            velocities[idx + 1] *= DAMPING;
            velocities[idx + 2] *= DAMPING;

            positions[idx] += velocities[idx];
            positions[idx + 1] += velocities[idx + 1];
            positions[idx + 2] += velocities[idx + 2];

            let tr = targetColors[idx];
            let tg = targetColors[idx + 1];
            let tb = targetColors[idx + 2];
            if (repelActive) {
              tr = scatterColor.r;
              tg = scatterColor.g;
              tb = scatterColor.b;
            }

            const glow = 1 + modePulse * 0.5;
            tr = Math.min(1, tr * glow);
            tg = Math.min(1, tg * glow);
            tb = Math.min(1, tb * glow);

            colors[idx] += (tr - colors[idx]) * COLOR_EASE;
            colors[idx + 1] += (tg - colors[idx + 1]) * COLOR_EASE;
            colors[idx + 2] += (tb - colors[idx + 2]) * COLOR_EASE;

            if (scatterSizeActive) {
              const seed = sizeSeeds[i];
              const base = 0.9 + seed * 0.9;
              const pulse = 0.55 + 0.45 * Math.sin(time * 0.007 + seed * 12.0);
              const burst = 1 + modePulse * 0.8;
              sizes[i] = BASE_SIZE * base * pulse * burst;
            } else {
              const settle = BASE_SIZE * (1 + modePulse * 0.45);
              sizes[i] += (settle - sizes[i]) * 0.18;
            }
          }

          geometry.attributes.position.needsUpdate = true;
          geometry.attributes.color.needsUpdate = true;
          geometry.attributes.size.needsUpdate = true;
        }

        function handleResize() {
          width = window.innerWidth;
          height = window.innerHeight;
          sphereRadius = Math.min(width, height) * 0.18;
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          renderer.setSize(width, height);
          material.uniforms.uPixelRatio.value = renderer.getPixelRatio();
          camera.left = -width / 2;
          camera.right = width / 2;
          camera.top = height / 2;
          camera.bottom = -height / 2;
          camera.updateProjectionMatrix();
          generateSpherePoints(sphereRadius);
          generateCloudTargets();
          if (mode === "text") {
            setModeText(activeTextKey);
          } else if (mode === "cloud") {
            setModeCloud();
          }
        }

        let lastFpsTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        function animate(time) {
          requestAnimationFrame(animate);
          updateParticles(time);
          renderer.render(scene, camera);
          frameCount += 1;
          if (time - lastFpsTime > 1000) {
            fps = (frameCount * 1000) / (time - lastFpsTime);
            frameCount = 0;
            lastFpsTime = time;
            updateHud(fps);
          }
        }

        function initHands() {
          const video = document.getElementById("video");
          const hands = new Hands({
            locateFile: (file) =>
              `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`,
          });
          hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6,
          });
          hands.onResults(handleHands);

          const cameraFeed = new Camera(video, {
            onFrame: async () => {
              await hands.send({ image: video });
            },
            width: 1280,
            height: 720,
            facingMode: { ideal: "environment" },
          });

          cameraFeed
            .start()
            .then(() => {
              statusEl.textContent = "CAMERA READY";
            })
            .catch((err) => {
              statusEl.textContent = "CAMERA BLOCKED";
              console.error(err);
            });
        }

        seedParticles();
        generateSpherePoints(sphereRadius);
        generateCloudTargets();
        setModeText(1);

        document.fonts.ready.then(() => {
          if (mode === "text") {
            setModeText(activeTextKey);
          }
        });

        window.addEventListener("resize", handleResize);
        initHands();
        updateHud(0);
        requestAnimationFrame(animate);
      })();
    </script>
  </body>
</html>
